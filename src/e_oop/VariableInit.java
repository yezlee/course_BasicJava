package e_oop;

public class VariableInit {
	
	//변수를 초기화 하는 방법에 대해 알아보자
	
	//명시적 초기화
	int var = 10; //선언을 하면서 바로 값을 넣어주는게 초기화라고 함.
	static int staticVar = 20; //static는 변수에도 붙일수 있고 메소드에도 붙일수 있어???뭔말이지 
		
	//초기화 블럭 - 명시적 초기화 사용하면 값만 넣을수있는데 블럭 사용하면 여러줄의 코드를 넣을수있어 여러 로직이 필요한경우 초기화 블럭을 사용해서 초기화를 할수있음
	{
		var = 30;  // 인스턴스 변수를 초기화 하기 위해서는 초기화 블럭안에서 초기화를 한다?
	}//사용한적 없음. 우선은 몰라도 괜찮음
	
	static{ //클래스 변수를 초기화 하기 위해서
		staticVar = 40;
	}
	
	//생성자 라는걸 사용해서 하는 초기화. 이게 오늘 키포인트!!!!!!!!!!!!!!!!!
	/*
	 * 생성자
	 * - 클래스와 같은 이름의 메소드 //new옆에 괄호 붙은건 무조건 메서드. 클래스와 같은 이름을 가진 메소드가 생성자야
	 * - 인스턴스 변수를 초기화 하기 위해 사용한다.
	 * - 클래스에 생성자는 반드시 하나이상 존재해야 한다.
	 * - 직접 선언해 주지 않으면 컴파일러가 기본 생성자를 만들어준다. 기본생성자는 아무 내용이 없는걸 말함
	 * - 생성자는 리턴타입이 없다.
	 * 
	 */
	
	VariableInit(){
		var = 50; //생성자란 인스턴스변수를 초기화하기 위한 메서드임
//		staticVar = 60; 
		//클래스 변수를 생성자에서 초기화 할수는 있지만 그닥 좋은방법아냐
		//값을 공유해야 하는 클래스 변수가 객체 생성 시 마다 계속 초기화 되기 때문에
		//기존에 유지하던 값이 있는데 이 초기화로 인해 바뀔수가 있자너. 유지 잘하고 있었는데!
		//클래스 변수를 생성자에서 초기화 하는 것은 좋지 않다.
		
		//생성자 사용 이유
		//초기화에 여러줄의 코드가 필요할때- 어떤 로직에 의해서
		//초기화에 파라미터가 필요할 때 - 얘는 메소드니까 파라미터를 받아서 초기화 할수 있음
				
	}
	
	public static void main(String[] args) {
		Init i = new Init();
		i.a = 10;
		i.b = 20;
		i.c = 30;
		
		Init i2 = new Init(); //얘도 생성자를 호출하는거임. 근데 이건 컴파일러가  생성자를 만든거임. 근데 그 아래 다른 생성자가 없을때 만드는거. 그치만 우린 이미 아래 생성자를 만듦 그래서 컴파일 에러뜸
		i2.a = 40;
		i2.b = 50;
		i2.c = 60;
		// 이렇게 매번 객체생성 할때마다 일일이 이렇게 해줘야하는데 불편해서 아래 클래스 이닛에서 하는것처럼
		
		
		//또한번 객체를 생성해보자
		Init i3 = new Init(70, 80, 90);
		//간결하게 요로코롬 가능. 위에는 일일이 다  열거해 줬는데
		// 이런이유로 생성자를 만들어 사용한다.
		
	}
	
	
	
}

class Init{
	int a;
	int b;
	int c;
	
	Init(int a, int b, int c){
		this.a = a;
		this.b = b;
		this.c = c;
		//this : 인스턴스 변수와 지역변수의 이름이 같을 때 둘을 구분하기 위해 사용한다.
		//이렇게  this를 붙이지 않으면 지역변수임. 파라미터
		
	}
	
	//위에서 컴파일 에러 뜬거때문에 걔를 위해 생성자를 만들어보자. 파라미터가 없는 생성자
	Init(){
		this(10, 20, 30); // 이건 생성자 아래 첫줄에서만 사용가능. 첫줄!!!!!!!!!!!!!
		a = 10;
		b = 20;
		c = 30;		
		//this() : 생성자에서 다른 생성자를 호출할 때 사용한다.
	}
    //메소드는 똑같은 이름 만들수 있음. 대신에 파라미터로 구분을해. 위에 이닛은 인트 에이 비 씨. 바로 위에건 파라미터가 아예 없지
	//이렇게 같은 이름의 메서드를 여러개 정의하는것을 오버로딩이라 함.
	
	//오버로딩 :  같은 이름의 메서드를 여러개 정의하는 것
	
//	System.out.println // 대표적인 오버로딩 된 메소드임. println뒤로 많은 파라미터가 존재

	
	
	
	
}


























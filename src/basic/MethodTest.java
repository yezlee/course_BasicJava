package basic;

import java.util.Scanner;

public class MethodTest {

		/*
		 * 메소드 = 함수
		 * 기능을 해주는 
		 * 
		 *  메서드(Method) ==> 특정한 기능을 처리하는 코드들의 집합
		 *  
		 *  형식>
		 *  접근제한자 반환값타입 메서드명(파라미터변수들...){  ==> 메서드 선언부(헤더)
		 *  	처리할 내용들;
		 *		....
		 *		return 반환값;    
		 *  }
		 *  
		 *  메소드실행 = 호출
		 *  
		 *  
		 *  - 메소드 호출방법
		 *  1) 파라미터변수와 반환값이 없는 메서드 호출하기
		 *  	형식 > 메소드명();
		 *  2) 파라미터변수는 있고 반환값이 없는 메서드 호출하기
		 * 		형식 > 메소드명(값들...); -> 값이 변수에 순서대로 들어감. 파라미터 변수에.
		 *  3) 파라미터변수는 없고 반환값이 있는 메서드 호출하기
		 *  	형식 > 변수 = 메소드명();
		 *    	변수 = a + b + 메서드명();
		 			-> 이렇게 사용할수도 있음. 오른쪽부터 실행됨/ 메서드 먼저 처리하고 반환값이랑 다시 식이랑 사용을 하는거야.    
		 *  4) 파라미터변수와 반환값이 있는 메서드 호출
		 *  	형식 > 변수 = 메소드명(값들...);
		 */
	
	//1. 반환값과 파라미터변수가 없는 메소드
	public static void insa(){
		System.out.println("안녕하세요!");
	}	//이렇게 리턴할 값이 없고, 리턴을 쓰더라고 끝에 써야하는경우는 주로 생략. 
	
	
	//메소드는 만들었다고 바로 실행되는건 아님. 
	//만들어진건 명령어가 메모리에 저장만 된거. 그래서 호출해야해
	//메소드 앞에 insa명 앞에 반환값이 없으니까 보이드
	
	
	//2. 반환값은 없고 파라미터변수가 있는 메소드
	public static void insa2(String name, int age){  //파라미터 변수는 일반 변수 쓰는거랑 비슷해.
		if(age < 10){
			return; // 이건 보이드 있을때는 내가 if문 써서 나이가 10살미만이면 그냥 리턴. 그말인즉슨 출력하지 말고 끝내란 소리.
		}		
		System.out.println("나이가 " + age + "세인" + name + "씨 안녕하세요!");
	}
	
	//어떤 종류의 데이터를 갖고 돌아가는지 알려주는게 반환값 타입
	
	
	//3. 반환값은 있고 파라미터변수(매개변수)는 없는 메소드
	public static String getName(){
		Scanner scan = new Scanner(System.in);
		System.out.println("이름 입력 : ");
		String name = scan.nextLine();
		
		return name; // 리턴값의 종류와 반환값 타입과 같아야지. string 이니깐 name.
	}
	
	
	
	//4. 반환값과 파라미터변수가 있는 메서드
	public static int add(int a, int b){
		int c = a - b;
		return c;
	//	return a+b;
	}
	
	
	
	public static void main(String[] args) {
	//1	insa(); // 이렇게 하면 저 위에있는 인사한테 가. 메소드를 실행하고 다시 자길 호출했던 아래 인사 처음한테가 그리고 메소드 안에 있는걸 실행하고(프린트한거지 여기선) 그리고 다시 두번째 인사한테 가고..
	//1	insa();

	//2	insa2("홍길동", 33); // 여기에 쓰여진 순서대로 들어감.
		
		//위에 처럼 직접 값을 지정해줄수도 있지만ㅇ 아래처험 할수도 있음
	//2	String irum = "일지매";
	//2	int num = 40;
	//2	insa2(irum, num);// 항상 값만 가져가. irum이라는 변수가 직접 가는게 아니고 그안에 들어있는 값. 일지매라는 그 값이 가는거야. 값을 복사해서 가지고 가서 위에다 넣어주는거야
		
		
		
	/*3//변수 = 메소드명();
		getName();		
		//반환값이 뭐가 들어오든 버리겠다. 그럼 위에 처럼 써도돼 근데 보통 반환값이 있다는건 내가 뭔 처리하곳 싶다는거. 값이 있음 변수에다 담아야하는데. 그게 같은 타입이어야하는거지.
		
		String str = getName();
		System.out.println("1. 당신의 이름은  " + str + "이군요.");
		
		System.out.println("2. 당신의 이름은  " + getName() + "이군요.");*/
		
		
		int hap = add(100, 200); //add라는 변수가 있고. 파라미터가 있네. 위에 애드한테 가서 값을 넣어주고 실행해서 얻은 결과값을 hap한테 넣어주고 아랫줄에 프린트해서 출력!
		System.out.println("100 + 200 = " + hap);
		
		//위에처럼해도되고 아래처럼 해도되고
		
		int a = 400;
		int b = 600;
		System.out.println(a + " + " + b + " = " +  add(b,a));  //여깄는 int a, b는 위에있는거랑은 별개. 
		//저렇게 초기화 해준건 아무런 힘이 없어 아래 시스템할때 add라는 변수가 있네, 그걸 불러준 값한테 지역변수 a랑 b에 있는 값만, 즉 100, 200을 위에 가서 실행.
		//add(a,b) 이건 값만 올라가. 값만 가기때문에 순서가 들어가는대로 출력. 만약 b,a로 하면, 
		// public static int add(int a, int b) <- 여기에 있는 int a 로 b의 값(600)이 들어감. 순서대로 a는 뒤에 있는 int b한테 값(400)만 들어가.
		//위에 add라는 이름의 메소드 안에 있는 int a랑 지금 여기 있는 메인메소드 안에 int a랑은 다른애니깐. 
		
		
		
		
		
		
		/*만약에 스태틱을 안붙였어 저 위에다가
		그러면 우선 메인메소드 안에다가 객체생성을 해줘야돼
		클래스명 MethodTest abc = new MethodTest();
		이렇게 해주고 위에 애들 쓸때 abc.
		
		*/
		
		
		
		
		
	}

	
	
	
	
	
	
	
	
	
	//  = 왼쪽은 항상 변수여야함. =오른쪽에 있는 식이든 뭔가를 그걸 먼저 처리해. 그것의 결과를 = 왼쪽에 있는 변수에 저장하라는 뜻. 
	
	
	
	
	
	
	
	
	
	
	
	
	
}
